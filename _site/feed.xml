<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>很Low的程序猿</title>
    <description></description>
    <link>gufei.me/</link>
    <atom:link href="gufei.me/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 17 Mar 2016 13:14:54 +0800</pubDate>
    <lastBuildDate>Thu, 17 Mar 2016 13:14:54 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>hell kotlin</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“Yeah It’s on. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;Blog 就这么开通了。&lt;/p&gt;
</description>
        <pubDate>Mon, 29 Feb 2016 20:00:00 +0800</pubDate>
        <link>gufei.me/2016/02/29/kotlin/</link>
        <guid isPermaLink="true">gufei.me/2016/02/29/kotlin/</guid>
        
        <category>kotlin</category>
        
        
      </item>
    
      <item>
        <title>初次接触Kotlin</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“用Kotlin开发android更简洁(￣_,￣ )”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;kotlinhttpskotlinlangorg&quot;&gt;&lt;a href=&quot;https://kotlinlang.org/&quot;&gt;Kotlin介绍&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Kotlin 是在2016年2月16号正式发布了1.0版本，是一个基于 JVM 的新的编程语言， Kotlin是一门与Swift类似的静态类型JVM语言,由JetBrains设计开发并开源。&lt;/p&gt;

&lt;p&gt;与Java相比，Kotlin的语法更简洁、更具表达性，而且提供了更多的特性，比如，高阶函数、操作符重载、字符串模板。它与Java高度可互操作，可以同时用在一个项目中，要比Java更安全，更简洁，能够兼容java，编译速度至少同java一样快。&lt;/p&gt;

&lt;h2 id=&quot;ide&quot;&gt;关于IDE工具&lt;/h2&gt;
&lt;p&gt;开发工具当然首选studio,具体优势也就不说了。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;环境搭建&lt;/h2&gt;
&lt;p&gt;android studio 已经有支持java转Kotlin的插件了，
&lt;img src=&quot;http://img.blog.csdn.net/20151205015447245&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Jan 2016 20:00:00 +0800</pubDate>
        <link>gufei.me/2016/01/29/hello-2016/</link>
        <guid isPermaLink="true">gufei.me/2016/01/29/hello-2016/</guid>
        
        <category>生活</category>
        
        
      </item>
    
      <item>
        <title>深入理解Android Gradle</title>
        <description>&lt;p&gt;#深入理解Android Gradle&lt;/p&gt;

&lt;p&gt;新的android开发工具引用了Gradle构建工具，方便了开发者进行构建不同的应用版本以完成不同的需求。（从此多版本不再痛苦）&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;gradle&quot;&gt;gradle基本语法&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;新建项目把默认的配置文件粘贴来&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apply plugin: &#39;com.android.application&#39;
android {
    compileSdkVersion 22
    buildToolsVersion &quot;19.1.0&quot;
    defaultConfig {
        applicationId &quot;org.guf.mediagesturedetector&quot;
        minSdkVersion 22
        targetSdkVersion 22
        versionCode 1
        versionName &quot;1.0&quot;
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
        }
    }
}
dependencies {
    compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])
    testCompile &#39;junit:junit:4.12&#39;
    compile &#39;com.android.support:appcompat-v7:22.2.1&#39;
    compile &#39;com.android.support:design:22.2.1&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;apply plugin&lt;/strong&gt;：
我的理解为构建版本，当你作为一个普通的安卓应用程序的时候为
apply plugin: ‘com.android.application’
当你作为安卓modle形式为apply plugin: ‘com.android.library’
当然最简单的只是java项目则为 apply plugin: ‘java’&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;android&lt;/strong&gt;
这个标签下主要包含了应用程序编译的sdkapi版本，sdkbuildTools的版本
defaultConfig 里包含了manifests里的编译属性
buildTypes 里包含了输出版本的类型
当然这些是可扩充的，这个下面会说到&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;dependencies&lt;/strong&gt;
android studio的依赖库配置
开发工具给我们提供了三种方式添加依赖包，这就是gradle带来的好处
&lt;img src=&quot;http://img.blog.csdn.net/20151205010619779&quot; alt=&quot;项目右键&quot; /&gt;
第一种是通过maven仓库下载在线的依赖库，比较依赖网络，但是更新编辑，后期只需要修改版本号即可&lt;/p&gt;

&lt;p&gt;第二种是以文件的方式引入jar文件，如果你是eclipse转过来的话就用的是这种方式，当然如果你已经配置了
compile fileTree(dir: ‘libs’, include: [‘*.jar’])
那么就无需手动的添加，它自动加载libs里的jar包&lt;/p&gt;

&lt;p&gt;第三种就是引入项目中的modle项目，这个无需多讲，跟eclipse中添加library类似&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;gradleandroidmanifest&quot;&gt;通过gradle替换AndroidManifest中的占位符&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;application
        android:allowBackup=&quot;true&quot;
        android:icon=&quot;@mipmap/ic_launcher&quot;
        android:label=&quot;${APP_NAME}&quot;
        android:theme=&quot;@style/AppTheme&quot;&amp;gt;
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在我需要在AndroidManifest中添加占位符’APP_NAME’,通过gradle编译的过程中，通过bulid.gradle修改它，
manifestPlaceholders=[占位符：需要修改的值]
&lt;code&gt;
buildTypes {
        release {
            manifestPlaceholders = [APP_NAME: &#39;test&#39;]
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
        }
    }
&lt;/code&gt; &lt;br /&gt;
3. 独立配置签名信息
————-&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;对于签名相关的信息,直接写在gradle当然不好,特别是一些开源项目，可以添加到gradle.properties:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RELEASE_KEY_PASSWORD=xxxx
RELEASE_KEY_ALIAS=xxx
RELEASE_STORE_PASSWORD=xxx
RELEASE_STORE_FILE=../.keystore/xxx.jks 然后在build.gradle中引用即可： ``` android {
signingConfigs {
    release {
        storeFile file(RELEASE_STORE_FILE)
        storePassword RELEASE_STORE_PASSWORD
        keyAlias RELEASE_KEY_ALIAS
        keyPassword RELEASE_KEY_PASSWORD
    }
} } ```    4. 多版本生产环境 -------------
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;p&gt;版本发布的流程分为：
```flow
st=&amp;gt;start: 开发
op=&amp;gt;operation: 回归测试
cond=&amp;gt;condition: 满足上线条件?
e=&amp;gt;end: 发布&lt;/p&gt;

&lt;p&gt;st-&amp;gt;op-&amp;gt;cond
cond(yes)-&amp;gt;e
cond(no)-&amp;gt;op
```
所以，我们的版本可以分为三种版本
debug-开发测试版
preview-测试预览版
release-正式版&lt;/p&gt;

&lt;p&gt;每个版本都会有不同的要求，测试版不能影响生产环境，不用通过改代码来切换测试环境和生产环境，可以增加自定义Build Type完成此类版本需求&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151205015447245&quot; alt=&quot;这里写图片描述&quot; /&gt;
在这个目录下会有个BuildConfig，我们可以用配置这里面的值来切换全局log的开关，保证生产环境不会泄漏log日志
&lt;code&gt;
    buildTypes {
        debug {
            buildConfigField &quot;boolean&quot;, &quot;DEBUG&quot;, &quot;true&quot;
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
        }
        release {
            buildConfigField &quot;boolean&quot;, &quot;DEBUG&quot;, &quot;false&quot;
            minifyEnabled true
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
        }
    }
&lt;/code&gt;
5. build type中的定制参数
————-&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;我这里列几个我在工作中用到的：
&lt;code&gt;
android {
        debug {
            manifestPlaceholders = [app_label:&quot;@string/app_name_debug&quot;]
            applicationIdSuffix &quot;.debug&quot;
            minifyEnabled false
            signingConfig signingConfigs.debug
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
        }
        release {
            manifestPlaceholders = [app_label:&quot;@string/app_name&quot;]
            minifyEnabled true
            shrinkResources true
            signingConfig signingConfigs.release
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
        }
        preview{
            manifestPlaceholders = [app_label:&quot;@string/app_name_preview&quot;]
            applicationIdSuffix &quot;.preview&quot;
            debuggable true // 保留debug信息
            minifyEnabled true
            shrinkResources true
            signingConfig signingConfigs.preview
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
        }
    }
}
&lt;/code&gt;
这些都用的太多了，稍微解释一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// minifyEnabled 混淆处理
// shrinkResources 去除无用资源
// signingConfig 签名
// proguardFiles 混淆配置
// applicationIdSuffix 增加APP ID的后缀
// debuggable 是否保留调试信息
// ... ...
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;section&quot;&gt;多工程全局配置&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;p&gt;随着产品渠道的铺开，往往一套代码需要支持多个产品形态，这就需要抽象出主要代码到一个Library，然后基于Library扩展几个App Module。
相信每个module的build.gradle都会有这个代码：
```
android {
    compileSdkVersion 22
    buildToolsVersion “23.0.1”&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;defaultConfig {
    minSdkVersion 10
    targetSdkVersion 22
    versionCode 34
    versionName &quot;v2.6.1&quot;
} } ``` 当升级sdk、build tool、target sdk等，几个module都要更改，非常的麻烦。最重要的是，很容易忘记，最终导致app module之间的差异不统一，也不可控。 强大的gradle插件在1.1.0支持全局变量设定，一举解决了这个问题。 先在project的根目录下的build.gradle定义ext全局变量: ``` ext {
compileSdkVersion = 22
buildToolsVersion = &quot;23.0.1&quot;
minSdkVersion = 10
targetSdkVersion = 22
versionCode = 34
versionName = &quot;v2.6.1&quot; } ``` 然后在各module的build.gradle中引用如下： ``` android {
compileSdkVersion rootProject.ext.compileSdkVersion
buildToolsVersion rootProject.ext.buildToolsVersion

defaultConfig {
    applicationId &quot;com.xxx.xxx&quot;
    minSdkVersion rootProject.ext.minSdkVersion
    targetSdkVersion rootProject.ext.targetSdkVersion
    versionCode rootProject.ext.versionCode
    versionName rootProject.ext.versionName
} } ``` 然后每次修改project级别的build.gradle即可实现全局统一配置。
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;apk&quot;&gt;自定义导出的APK名称&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;p&gt;默认android studio生成的apk名称为app-debug.apk或者app-release.apk，当有多个渠道的时候，需要同时编出50个渠道包的时候，就麻烦了，不知道谁是谁了。
这个时候，就需要自定义导出的APK名称了，不同的渠道编出的APK的文件名应该是不一样的。
&lt;code&gt;
android {
    // rename the apk with the version name
    applicationVariants.all { variant -&amp;gt;
        variant.outputs.each { output -&amp;gt;
            output.outputFile = new File(
                    output.outputFile.parent,
                    &quot;ganchai-${variant.buildType.name}-${variant.versionName}-${variant.productFlavors[0].name}.apk&quot;.toLowerCase())
        }
    }
}
&lt;/code&gt;
当apk太多时，如果能把apk按debug，release，preview分一下类就更好了（事实上，对于我这样经常发版的人，一编往往就要编四五十个版本的人，debug和release版本全混在一起没法看，必须分类），简单：
&lt;code&gt;
android {
    // rename the apk with the version name
    // add output file sub folder by build type
    applicationVariants.all { variant -&amp;gt;
        variant.outputs.each { output -&amp;gt;
            output.outputFile = new File(
                    output.outputFile.parent + &quot;/${variant.buildType.name}&quot;,
                    &quot;ganchai-${variant.buildType.name}-${variant.versionName}-${variant.productFlavors[0].name}.apk&quot;.toLowerCase())
        }
    }
}
&lt;/code&gt;
现在生成了类似于ganchai-dev-preview-v2.4.0.0.apk这样格式的包了，preview的包自然就放在preview的文件夹下，清晰明了。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;section-1&quot;&gt;多渠道打包&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;p&gt;多渠道打包的关键之处在于，定义不同的product flavor, 并把AndroiManifest中的channel渠道编号替换为对应的flavor标识：
&lt;code&gt;
android {
    productFlavors {
        dev{
            manifestPlaceholders = [channel:&quot;dev&quot;]
        }
        official{
            manifestPlaceholders = [channel:&quot;official&quot;]
        }
        // ... ...
        wandoujia{
            manifestPlaceholders = [channel:&quot;wandoujia&quot;]
        }
        xiaomi{
            manifestPlaceholders = [channel:&quot;xiaomi&quot;]
        }
        &quot;360&quot;{
            manifestPlaceholders = [channel:&quot;360&quot;]
        }
}
&lt;/code&gt;
注意一点，这里的flavor名如果是数字开头，必须用引号引起来。
构建一下，就能生成一系列的Build Variant了:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;devDebug
devRelease
officialDebug
officialRelease
wandoujiaDebug
wandoujiaRelease
xiaomiDebug
xiaomiRelease
360Debug
360Release 其中debug, release是gradle默认自带的两个build type, 下一节还会继续说明。 选择一个，就能编译出对应渠道的apk了。    
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;section-2&quot;&gt;动态设置一些额外信息&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;p&gt;假如想把当前的编译时间、编译的机器、最新的commit版本添加到apk，而这些信息又不好写在代码里，强大的gradle给了我创造可能的自信：
```
android {
    defaultConfig {
        resValue “string”, “build_time”, buildTime()
        resValue “string”, “build_host”, hostName()
        resValue “string”, “build_revision”, revision()
    }
}&lt;/p&gt;

&lt;p&gt;def buildTime() {
    return new Date().format(“yyyy-MM-dd HH:mm:ss”)
}
def hostName() {
    return System.getProperty(“user.name”) + “@” + InetAddress.localHost.hostName
}
def revision() {
    def code = new ByteArrayOutputStream()
    exec {
        commandLine ‘git’, ‘rev-parse’, ‘–short’, ‘HEAD’
        standardOutput = code
    }
    return code.toString()
}
```
上述代码实现了动态的添加了3个字符串资源: build_time、build_host、build_revision, 然后在其他地方可像如引用字符串一样&lt;/p&gt;

</description>
        <pubDate>Wed, 16 Dec 2015 00:00:00 +0800</pubDate>
        <link>gufei.me/2015/12/16/android-gradle/</link>
        <guid isPermaLink="true">gufei.me/2015/12/16/android-gradle/</guid>
        
        <category>Android</category>
        
        
      </item>
    
  </channel>
</rss>
